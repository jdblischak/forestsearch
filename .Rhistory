model = "alt",
# Spline specification for non-linear biomarker effect
spline_spec = list(
var = "z_bm",                    # Variable with non-linear effect
knot = 5,                        # Spline knot position
zeta = 10,                       # Transition smoothness parameter
log_hrs = log(c(2, 1.25, 0.5))  # Hazard ratios for three segments
),
verbose = TRUE,
standardize = FALSE #default
)
devtools::document()
devtools::load_all()
dgm_spline <- generate_aft_dgm_flex(
data = df.case,
# Main effects: continuous and factor variables
# NOTE that ALL variables in the outcome model will have a "z_" prefix attached
continuous_vars = c("age", "bm"),
factor_vars = c("male", "histology", "prior_treat", "AP"),
# Force specific coefficient for AP variable
set_beta_spec = list(
set_var = c("z_AP"),
beta_var = -log(5)  # HR = 0.2 (strong protective effect)
),
# Censoring mechanism covariates
# NOTE that ALL variables in the censoring model will have a "zcens_" prefix attached
# See notes below on how the censoring model is selected
continuous_vars_cens = c("age"),
factor_vars_cens = c("prior_treat"),
cens_type = "weibull",
# Outcome specification
outcome_var = "tte",
event_var = "event",
treatment_var = "treat",
# No additional subgroup factors
subgroup_vars = NULL,
subgroup_cuts = NULL,
k_inter = 0.0,
# indicate that subgroup effects are incorporated
model = "alt",
# Spline specification for non-linear biomarker effect
spline_spec = list(
var = "z_bm",                    # Variable with non-linear effect
knot = 5,                        # Spline knot position
zeta = 10,                       # Transition smoothness parameter
log_hrs = log(c(2, 1.25, 0.5))  # Hazard ratios for three segments
),
verbose = TRUE,
standardize = FALSE #default
)
library(dplyr)
b0_coefs <- dgm_spline$model_params$b0
coef_df <- data.frame(
Coefficient = names(b0_coefs),
Value = as.numeric(b0_coefs),
HR = exp(as.numeric(b0_coefs))
) |>
mutate(
Type = case_when(
grepl("^treat", Coefficient) ~ "Treatment Effects",
grepl("^z_bm", Coefficient) ~ "Biomarker (Spline)",
grepl("^z_", Coefficient) ~ "Baseline Covariates",
TRUE ~ "Other"
)
)
coef_table_grouped <- coef_df |>
arrange(Type, Coefficient) |>
gt(groupname_col = "Type") |>
fmt_number(
columns = c(Value, HR),
decimals = 4
) |>
tab_header(
title = "AFT Model Coefficients by Type",
subtitle = "Weibull Parameterization (b0) with Hazard Ratios"
) |>
cols_label(
Coefficient = "Variable",
Value = "b0 Coefficient",
HR = "Hazard Ratio"
) |>
tab_style(
style = cell_text(weight = "bold"),
locations = cells_column_labels()
) |>
tab_style(
style = cell_text(style = "italic"),
locations = cells_row_groups()
) |>
tab_options(
table.font.size = px(12)
)
coef_table_grouped
# Confirm forced parameter value
#cat("AP region parmeter = -log(5)?", c(dgm_spline$model_params$b0["z_AP"],-log(5)),"\n")
-log(5)
dgm_spline$model_params$censoring
# Note that here flag_harm is not relevant because of the spline specification and definition of "harm" depends on degree
# In discussion below we describe how to specify thresholds of "harm" corresponding to biomarker effects
create_summary_table(data=dgm_spline$df_super, treat_var="treat",
table_title = "Super-population Characteristics by Treatment Arm",
vars_continuous=c("z_age","z_bm","entrytime","lin_pred_1","lin_pred_0","loghr_po"),
vars_categorical=c("z_male","z_histology","z_prior_treat","z_AP","ecog","strat","region_other","flag_harm"),
font_size = 12)
names(dgm_spline)
namds(dgm_spline$df_super)
names(dgm_spline$df_super)
summary(dgm_spline$df_super)
# Generate a dataset with n=500 subjects:
# Randomized 1:1 (rand_ratio=1);
# Retain the original treatment assignment in df.case (draw_treatment=FALSE)
# Note that draw_treatment=TRUE will draw randomized treatment assignments
# Use observed entry times per df.case if provided (entry_var = entrytime);
# Otherwise entry times are simulated as uniform(0, max_entry)
# Entry times are then incorporated in administrative censoring at the time
# of analysis (eg., analysis_time = 60);
# That is, subjects with entrytime > analysis_time are not available
# and follow-up is "60 - entrytime" for each subjects entrytime value
# The cens_adjust argument allows for increasing or decreasing the mean of
# the censoring distribution in order to reduce or increase the censoring rate
df_example <- simulate_from_dgm(
dgm = dgm_spline,
n = 500,
rand_ratio = 1,
draw_treatment = FALSE,
entry_var = "entrytime",
analysis_time = 60,
cens_adjust = 0,
seed = 12345
)
# Examine the simulated data structure
head(df_example)
# Note that y_sim, treat_sim, and event_sim are the outcomes, treatment, and events for the simulated data
# t_true are the uncensored outcomes, and c_time are the uncensored (not censored by outcomes) censoring times
# Of course in reality t_true and c_time are not observable
create_summary_table(data = df_example, treat_var="treat_sim",
table_title = "Simulated data (n=500) from Spline Model",
vars_continuous=c("y_sim","t_true","c_time","z_age","z_bm","entrytime","lin_pred_1","lin_pred_0","loghr_po"),
vars_categorical=c("event_sim","z_male","z_histology","z_prior_treat","z_AP","ecog","strat","region_other","flag_harm"))
# Plot the spline effect
plot_spline_treatment_effect(dgm_spline)
# Large sample approximation
df_large <- simulate_from_dgm(
dgm = dgm_spline,
n = 5000,
rand_ratio = 1,
draw_treatment = FALSE,
entry_var = "entrytime",
analysis_time = 60,
cens_adjust = 0,
seed = 12345
)
# hr_threshold = 1.25 specifies finding the biomarker level such that the AHR (loghr_po) is above 1.25
results <- cox_ahr_cde_analysis(
df = df_large,
tte_name = "y_sim", event_name = "event_sim", treat_name = "treat_sim",
z_name = "z_bm",
hr_threshold = 1.25,
plot_style = "grid"
)
res <-results$subgroup_stats
cut_hr <- results$optimal_cutpoint
res |>
gt() |>
tab_header(
title = "Subgroup Statistics"
) |>
tab_source_note(
source_note = md(paste0("*HR threshold biomarker cutpoint: ",
round(cut_hr, 3), "*"))
) |>
# Format first 3 columns with 0 decimals
fmt_number(
columns = 1:4,
decimals = 0
) |>
# Format remaining numeric columns with 3 decimals
fmt_number(
columns = -c(1:4),
decimals = 3
) |>
tab_style(
style = cell_text(weight = "bold"),
locations = cells_column_labels()
) |>
tab_options(
table.font.size = px(12)
)
# ITT
dfc <- df_counting(
df = df_example,
by.risk = 6,
tte.name = "y_sim",
event.name = "event_sim",
treat.name = "treat_sim"
)
# No censoring
# Except by max_follow
df_example$t_true <- pmin(df_example$t_true, 100)
df_example$event_mod <- ifelse(df_example$t_true <= 100,1,0)
dfideal <- df_counting(
df = df_example,
by.risk = 6,
tte.name = "t_true",
event.name = "event_mod",
treat.name = "treat_sim"
)
df_nonAP <- subset(df_example, z_AP == 0)
df_AP <- subset(df_example, z_AP == 1)
# non-AP
dfc0 <- df_counting(
df = df_nonAP,
by.risk = 6,
tte.name = "y_sim",
event.name = "event_sim",
treat.name = "treat_sim"
)
# AP
dfc1 <- df_counting(
df = df_AP,
by.risk = 6,
tte.name = "y_sim",
event.name = "event_sim",
treat.name = "treat_sim"
)
par(mfrow=c(2,2))
plot_weighted_km(dfideal, conf.int = FALSE, show.logrank = TRUE, ymax = 1.1, xmed.fraction = 0.75, ymed.offset = 0.15)
title("ITT no censoring (through 100 months)")
plot_weighted_km(dfc, conf.int = FALSE, show.logrank = TRUE, ymax = 1.1, xmed.fraction = 0.75, ymed.offset = 0.15)
title("ITT censored")
plot_weighted_km(dfc0, conf.int = FALSE, show.logrank = TRUE, ymax = 1.1, xmed.fraction = 0.725, ymed.offset = 0.15)
title("non-AP")
plot_weighted_km(dfc1, conf.int = FALSE, show.logrank = TRUE, ymax = 1.1, xmed.fraction = 0.725, ymed.offset = 0.15)
title("AP")
result <- cox_cs_fit(
df = df_example, tte_name = "y_sim", event_name ="event_sim", treat_name = "treat_sim",
truebeta_name = "loghr_po",
z_name = "z_bm", z_by = 1, z_window = 0.5,
alpha = 0.20,
plot_params = list(
xlab = "Biomarker Level",
main_title = "Treatment Effect Heterogeneity"
)
)
confounders.name <- c("z_age","z_bm","z_male","ecog","z_histology","z_prior_treat","strat")
dfa <- as.data.frame(df_nonAP)
library(doFuture)
library(doRNG)
registerDoFuture()
registerDoRNG()
# Analysis dataset (estimation/training) is non-AP (df_nonAP)
# Testing dataset is AP (df_AP) --> predictions per non-AP analysis are applied to AP
system.time({fs <- forestsearch(dfa,  confounders.name=confounders.name,
outcome.name = "y_sim", treat.name = "treat_sim", event.name = "event_sim", id.name = "id",
potentialOutcome.name = "loghr_po",
df.test = as.data.frame(df_AP),
flag_harm.name = NULL,
hr.threshold = 0.9, hr.consistency = 0.80, pconsistency.threshold = 0.80,
sg_focus = "minSG", max_subgroups_search = 30,
showten_subgroups = TRUE, details=TRUE,
conf_force = c("z_age <= 65", "z_bm <= 0", "z_bm <= 1", "z_bm <= 2","z_bm <= 5"),
cut_type = "default", use_grf = TRUE, plot.grf = TRUE, use_lasso = TRUE,
maxk = 1, n.min = 60, d0.min = 12, d1.min = 12,
plot.sg = TRUE, by.risk = 6,
parallel_args = list(plan="callr", workers = 100, show_message = TRUE)
)
})
plan("sequential")
# Results for estimation (training) data, which_df = "est" is default
res_tabs <- sg_tables(fs, ndecimals = 3, which_df = "est")
res_tabs$sg10_out
res_tabs$tab_estimates
# Results for testing dataset (AP)
res_tabs <- sg_tables(fs, ndecimals = 3, which_df = "testing", est_caption = "Testing (AP) dataset")
res_tabs$tab_estimates
dgm_spline_null <- generate_aft_dgm_flex(
data = df.case,
continuous_vars = c("age", "bm"),
factor_vars = c("male", "histology", "prior_treat","AP"),
set_beta_spec = list(set_var = c("z_AP"), beta_var = -log(5)),
continuous_vars_cens = c("age"),
factor_vars_cens = c("prior_treat"),
outcome_var = "tte",
event_var = "event",
treatment_var = "treat",
cens_type = "weibull",
subgroup_vars = NULL,
subgroup_cuts = NULL,
model = "alt",
spline_spec = list(
var = "z_bm",  # Use original variable name (or "z_er" if transformed)
knot = 5,
zeta = 10,
log_hrs = log(c(0.7, 0.7, 0.7))  # HR varies with ER
),
k_inter = 0.0,  # Amplify or turn-off (=0) subgroup per subgroup_vars effect?
verbose = TRUE
)
# Simulate data
# cens_adjust  - 3.5
df_example <- simulate_from_dgm(
dgm = dgm_spline_null,
n = 500,
rand_ratio = 1,
draw_treatment = FALSE,
entry_var = "entrytime",
analysis_time = 60,
cens_adjust = 0,
seed = 12345
)
dim(df_example)
with(df_example,sum(event_sim))
# ITT
dfc <- df_counting(
df = df_example,
by.risk = 6,
tte.name = "y_sim",
event.name = "event_sim",
treat.name = "treat_sim"
)
# No censoring
# Except by max_follow
df_example$t_true <- pmin(df_example$t_true, 100)
df_example$event_mod <- ifelse(df_example$t_true <= 100,1,0)
dfideal <- df_counting(
df = df_example,
by.risk = 6,
tte.name = "t_true",
event.name = "event_mod",
treat.name = "treat_sim"
)
df_nonAP <- subset(df_example, z_AP == 0)
df_AP <- subset(df_example, z_AP == 1)
# non-AP
dfc0 <- df_counting(
df = df_nonAP,
by.risk = 6,
tte.name = "y_sim",
event.name = "event_sim",
treat.name = "treat_sim"
)
# AP
dfc1 <- df_counting(
df = df_AP,
by.risk = 6,
tte.name = "y_sim",
event.name = "event_sim",
treat.name = "treat_sim"
)
par(mfrow=c(2,2))
plot_weighted_km(dfideal, conf.int = FALSE, show.logrank = TRUE, ymax = 1.1, xmed.fraction = 0.75, ymed.offset = 0.15)
title("ITT no censoring (through 100 months)")
plot_weighted_km(dfc, conf.int = FALSE, show.logrank = TRUE, ymax = 1.1, xmed.fraction = 0.75, ymed.offset = 0.15)
title("ITT censored")
plot_weighted_km(dfc0, conf.int = FALSE, show.logrank = TRUE, ymax = 1.1, xmed.fraction = 0.725, ymed.offset = 0.15)
title("non-AP")
plot_weighted_km(dfc1, conf.int = FALSE, show.logrank = TRUE, ymax = 1.1, xmed.fraction = 0.725, ymed.offset = 0.15)
title("AP")
confounders.name <- c("z_age","z_bm","z_male","ecog","z_histology","z_prior_treat","strat")
dfa <- as.data.frame(df_nonAP)
# Setup parallel processing
library(doFuture)
library(doRNG)
registerDoFuture()
registerDoRNG()
system.time({fs <- forestsearch(dfa,  confounders.name=confounders.name,
outcome.name = "y_sim", treat.name = "treat_sim", event.name = "event_sim", id.name = "id",
potentialOutcome.name = "loghr_po",
df.test = as.data.frame(df_AP),
flag_harm.name = NULL,
hr.threshold = 0.9, hr.consistency = 0.80, pconsistency.threshold = 0.80,
sg_focus = "minSG", max_subgroups_search = 30,
showten_subgroups = TRUE, details=TRUE,
conf_force = c("z_age <= 65", "z_bm <= 0", "z_bm <= 1", "z_bm <= 2","z_bm <= 5"),
cut_type = "default", use_grf = TRUE, plot.grf = TRUE, use_lasso = TRUE,
maxk = 1, n.min = 60, d0.min = 12, d1.min = 12,
plot.sg = TRUE, by.risk = 6,
parallel_args = list(plan="callr", workers = 100, show_message = TRUE)
)
})
plan("sequential")
devtools::check()
library(devtools)
devtools::document()
devtools::check(cran = TRUE)     # Full CRAN validation
# Set options
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.align = 'center',
fig.retina = 2
)
rm(list=ls())
library(tinytex)
library(ggplot2)
library(table1)
library(gt)
# test these packages
# just for testing any conflicts
# library(tidyverse)
# library(plyr)
# library(dplyr)
# library(glmnet)
library(survival)
library(data.table)
library(randomForest)
library(grf)
library(policytree)
library(DiagrammeR)
library(grid)
library(forestploter)
library(randomizr)
# library(devtools)
# install_github("larry-leon/weightedsurv", force = TRUE)
#install.packages("weightedsurv")
# install_github("larry-leon/forestsearch", force = TRUE)
library(forestsearch)
library(weightedsurv)
#help(forestsearch)
#help(generate_aft_dgm_flex)
# Set theme for plots
theme_set(theme_minimal(base_size = 12))
# case-study example
# Draw sample from synthetic dataset (n=2,000)
dfsynth <- read.table("../data/dfsynthetic.csv", header=TRUE, sep=",")
df.case <- dfsynth
# Create "Asia Pacific (AP)" region flag variable
df.case$AP <- df.case$region_asia
dfcount <- df_counting(
df = df.case,
by.risk = 6,
tte.name = "tte",
event.name = "event",
treat.name = "treat"
)
plot_weighted_km(dfcount, conf.int = TRUE, show.logrank = TRUE, ymax = 1.05, xmed.fraction = 0.775, ymed.offset = 0.125)
names(df.case)
summary(df.case$pid)
# Restrict to 1st 500
df.case0 <- subset(df.case, pid <= 500)
dfcount <- df_counting(
df = df.case0,
by.risk = 6,
tte.name = "tte",
event.name = "event",
treat.name = "treat"
)
plot_weighted_km(dfcount, conf.int = TRUE, show.logrank = TRUE, ymax = 1.05, xmed.fraction = 0.775, ymed.offset = 0.125)
df.case0$bm10 <- ifelse(df.case0$bm >= 10, 1,0)
df.case0$bm10 <- ifelse(df.case0$bm >= 10, 1,0)
create_summary_table(data = df.case0, treat_var="treat",
table_title = "N=500 Characteristics by Treatment Arm",
vars_continuous=c("age","bm","entrytime"),
vars_categorical=c("male","histology","prior_treat","AP","ecog","strat","bm10"),
font_size = 12)
# Restrict to 1st 500
df.case0 <- subset(df.case, pid <= 500)
dfcount <- df_counting(
df = df.case,
by.risk = 6,
tte.name = "tte",
event.name = "event",
treat.name = "treat"
)
plot_weighted_km(dfcount, conf.int = TRUE, show.logrank = TRUE, ymax = 1.05, xmed.fraction = 0.775, ymed.offset = 0.125)
df.case$bm10 <- ifelse(df.case$bm >= 10, 1,0)
create_summary_table(data = df.case, treat_var="treat",
table_title = "N=500 Characteristics by Treatment Arm",
vars_continuous=c("age","bm","entrytime"),
vars_categorical=c("male","histology","prior_treat","AP","ecog","strat","bm10"),
font_size = 12)
# Set options
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.align = 'center',
fig.retina = 2
)
rm(list=ls())
library(tinytex)
library(ggplot2)
library(table1)
library(gt)
# test these packages
# just for testing any conflicts
# library(tidyverse)
# library(plyr)
# library(dplyr)
# library(glmnet)
library(survival)
library(data.table)
library(randomForest)
library(grf)
library(policytree)
library(DiagrammeR)
library(grid)
library(forestploter)
library(randomizr)
# library(devtools)
# install_github("larry-leon/weightedsurv", force = TRUE)
#install.packages("weightedsurv")
# install_github("larry-leon/forestsearch", force = TRUE)
library(forestsearch)
library(weightedsurv)
#help(forestsearch)
#help(generate_aft_dgm_flex)
# Set theme for plots
theme_set(theme_minimal(base_size = 12))
plot_weighted_km(dfc1, conf.int = TRUE, show.logrank = FALSE, ymax = 1, xmed.fraction = 0.725, ymed.offset = 0.15)
title("AP")
