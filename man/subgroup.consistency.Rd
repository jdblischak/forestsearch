% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/subgroup_consistency_main.R
\name{subgroup.consistency}
\alias{subgroup.consistency}
\title{Evaluate Subgroup Consistency}
\usage{
subgroup.consistency(
  df,
  hr.subgroups,
  hr.threshold = 1,
  hr.consistency = 1,
  pconsistency.threshold = 0.9,
  m1.threshold = Inf,
  n.splits = 100,
  details = FALSE,
  by.risk = 12,
  plot.sg = FALSE,
  maxk = 7,
  Lsg,
  confs_labels,
  sg_focus = "hr",
  stop_Kgroups = 10,
  stop_threshold = NULL,
  showten_subgroups = FALSE,
  pconsistency.digits = 2,
  seed = 8316951,
  checking = FALSE,
  use_twostage = FALSE,
  twostage_args = list(),
  parallel_args = list()
)
}
\arguments{
\item{df}{Data frame containing the analysis dataset. Must include columns
for outcome (Y), event indicator (Event), and treatment (Treat).}

\item{hr.subgroups}{Data.table of candidate subgroups from subgroup search,
containing columns: HR, n, E, K, d0, d1, m0, m1, grp, and factor indicators.}

\item{hr.threshold}{Numeric. Minimum hazard ratio threshold for candidates.
Default: 1.0}

\item{hr.consistency}{Numeric. Minimum HR required in each split for
consistency. Default: 1.0}

\item{pconsistency.threshold}{Numeric. Minimum proportion of splits that
must be consistent. Default: 0.9}

\item{m1.threshold}{Numeric. Maximum m1 threshold for filtering. Default: Inf}

\item{n.splits}{Integer. Number of splits for consistency evaluation.
Default: 100}

\item{details}{Logical. Print progress details. Default: FALSE}

\item{by.risk}{Numeric. Risk interval for KM plots. Default: 12}

\item{plot.sg}{Logical. Generate subgroup plots. Default: FALSE}

\item{maxk}{Integer. Maximum number of factors in subgroup. Default: 7}

\item{Lsg}{List of subgroup parameters.}

\item{confs_labels}{Character vector mapping factor names to labels.}

\item{sg_focus}{Character. Subgroup selection criterion: "hr", "maxSG",
or "minSG". Default: "hr"}

\item{stop_Kgroups}{Integer. Maximum number of candidates to evaluate.
Default: 10}

\item{stop_threshold}{Numeric or NULL. If specified, evaluation stops once
any subgroup achieves consistency >= stop_threshold. This enables early
termination when a sufficiently consistent subgroup is found. Default: NULL
(evaluate all candidates up to stop_Kgroups).

When combined with HR-based sorting (sg_focus = "hr"), this ensures the
highest-HR subgroup meeting the threshold is identified efficiently.

Note: For parallel execution, early stopping is checked after each batch
completes, so some additional candidates beyond the first meeting the
threshold may be evaluated. Use a smaller batch_size in parallel_args
for finer-grained early stopping.}

\item{showten_subgroups}{Logical. If TRUE, prints up to 10 candidate
subgroups after sorting by sg_focus, showing their rank, HR, sample size,
events, and factor definitions. Useful for reviewing which candidates
will be evaluated for consistency. Default: FALSE}

\item{pconsistency.digits}{Integer. Decimal places for consistency
proportion. Default: 2}

\item{seed}{Integer. Random seed for reproducible consistency splits.
Default: 8316951. Set to NULL for non-reproducible random splits.
The seed is used both for sequential execution (via set.seed()) and
parallel execution (via future.seed).}

\item{checking}{Logical. Enable additional validation checks. Default: FALSE}

\item{use_twostage}{Logical. Use two-stage adaptive algorithm. Default: FALSE}

\item{twostage_args}{List. Parameters for two-stage algorithm:
\describe{
\item{n.splits.screen}{Splits for Stage 1 screening. Default: 30}
\item{screen.threshold}{Consistency threshold for Stage 1. Default: auto}
\item{batch.size}{Splits per batch in Stage 2. Default: 20}
\item{conf.level}{Confidence level for early stopping. Default: 0.95}
\item{min.valid.screen}{Minimum valid Stage 1 splits. Default: 10}
}}

\item{parallel_args}{List. Parallel processing configuration:
\describe{
\item{plan}{Future plan: "multisession", "multicore", or "sequential"}
\item{workers}{Number of parallel workers}
\item{batch_size}{Number of candidates to evaluate per batch. Smaller
values provide finer-grained early stopping but may increase overhead.
Default: auto (workers when stop_threshold set, workers*2 otherwise)}
\item{show_message}{Print parallel config messages}
}}
}
\value{
A list containing:
\describe{
\item{out_sg}{Selected subgroup results}
\item{sg_focus}{Selection criterion used}
\item{df_flag}{Data frame with treatment recommendations}
\item{sg.harm}{Subgroup definition labels}
\item{sg.harm.id}{Subgroup membership indicator}
\item{algorithm}{"twostage" or "fixed"}
\item{n_candidates_evaluated}{Number of candidates actually evaluated}
\item{n_candidates_total}{Total candidates available}
\item{n_passed}{Number meeting consistency threshold}
\item{early_stop_triggered}{Logical indicating if early stop occurred}
\item{early_stop_candidate}{Index of candidate triggering early stop}
\item{stop_threshold}{Threshold used for early stopping}
\item{seed}{Random seed used for reproducibility (NULL if not set)}
}
}
\description{
Evaluates candidate subgroups using split-sample consistency validation.
For each candidate, repeatedly splits the data and checks whether the
treatment effect direction is consistent across splits.
}
\examples{
\dontrun{
# Standard evaluation
result <- subgroup.consistency(
  df = trial_data,
  hr.subgroups = candidates,
  sg_focus = "hr",
  n.splits = 400,
  parallel_args = list(plan = "multisession", workers = 6)
)

# Show top 10 candidates before evaluation
result <- subgroup.consistency(
  df = trial_data,
  hr.subgroups = candidates,
  sg_focus = "hr",
  showten_subgroups = TRUE,  # Display candidates
  n.splits = 400
)

# With early stopping and custom batch size
result <- subgroup.consistency(
  df = trial_data,
  hr.subgroups = candidates,
  sg_focus = "hr",
  stop_threshold = 0.95,
  showten_subgroups = TRUE,
  parallel_args = list(
    plan = "multisession",
    workers = 6,
    batch_size = 2  # Check early stopping after every 2 candidates
  )
)
}

}
