---
title: "GBSG SIM Revision: Primary analysis maximize consistency"
author: "Larry Leon"
output: html_document
---

```{=latex}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{enumerate}
\usepackage{threeparttable}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{url}
\usepackage[colorlinks=true,linkcolor={blue},citecolor={black},urlcolor={blue},runcolor={blue}]{hyperref}
```

```{r Rpackages, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)

rm(list=ls())
## Unnecessary packages commented out
suppressMessages(library(kableExtra,quietly=TRUE))
suppressMessages(library(knitr,quietly=TRUE))
suppressMessages(library(randomForest,quietly=TRUE))
suppressMessages(library(survival,quietly=TRUE))
suppressMessages(library(grf,quietly=TRUE))
suppressMessages(library(policytree,quietly=TRUE))
suppressMessages(library(DiagrammeR,quietly=TRUE))
suppressMessages(library(data.table,quietly=TRUE))
suppressMessages(library(plyr,quietly=TRUE))
suppressMessages(library(dplyr,quietly=TRUE))
suppressMessages(library(glmnet,quietly=TRUE))
# smd and gtsummary are for baseline summary table
# omit if not desired (remove corresponding section below)
suppressMessages(library(smd,quietly=TRUE)) # required for gtsummary
suppressMessages(library(gtsummary,quietly=TRUE)) # only for baseline table summary
suppressMessages(library(future,quietly=TRUE))
# Speff2trial for ACTG-175 dataset
suppressMessages(library(speff2trial,quietly=TRUE))
library(stringr)

```

```{r SetBootstrapCV, echo=TRUE, eval=TRUE}
## Output file name specification

file_out_here <- c("applications/gbsg/output/gbsg_v0B.Rdata")
#file_out_here <- NULL
# set file_out_here = NULL if not outputting results to file
# Bootstrapping and cross-validation
NB <- 2000 # Bootstraps
tenfoldsims <- 200 #10-fold cross-validation sims
dirpath1 <- c("/media/larryleon/My Projects/")
#dirpath1 <- c("/home/larryleon/Documents/")
```

```{r FileSetup, echo=TRUE, eval=TRUE}
## Directory and file output paths
## Set dirpath2 = NULL if only 1 system (here choosing between "Apple" for dirpath2 and "non-MAC" for dirpath1)
## If only 1 system then set dirpath2=NULL and dirpath1 according to your setup
## file_analysis denotes the forest-search full analysis results (fs.est)
setup_files <- function(dirpath1=c("/media/larryleon/My Projects/"),dirpath2=c("/Users/larryleon/Documents/"),
                        dir2_identifier="Apple",
                        dircode=c("GitHub/Forest-Search/R/"), 
                        resdir=c("GitHub/Forest-Search/paper/"),
                        file_out =NULL){
  # dirpath1 and dirpath2 then chose between two paths
  # here, running on different systems MAC versus linux
  if(!is.null(dirpath2)){
    suppressMessages(library(benchmarkme,quietly=TRUE))
    suppressMessages(library(parallelly,quietly=TRUE))  
    my_system <- get_cpu()
    my_ram <- get_ram()
    cat("Running on system:",c(my_system$model_name),"\n")
    cat("with number of cores and cpu/GB=",c(my_system$no_of_cores,round(c(my_ram)/10^9,0)),"\n")
    check_dir2 <- grepl(dir2_identifier,my_system$model_name)
    # Change to dirpath2
    if(check_dir2){
      dirpath <- dirpath2
      # Free connections
      free_cons <- c(availableCores())
    }
    if(!check_dir2){
      dirpath <- dirpath1
      # Free connections (for my popos system)
      free_cons <- c(freeConnections()-1)
    }
    cat("Number of free connections for doFuture/parallel =",c(free_cons),"\n")
  }
  if(is.null(dirpath2)){
    suppressMessages(library(benchmarkme,quietly=TRUE))
    suppressMessages(library(parallelly,quietly=TRUE))  
    my_system <- get_cpu()
    my_ram <- get_ram()
    cat("Running on system:",c(my_system$model_name),"\n")
    cat("with number of cores and cpu/GB=",c(my_system$no_of_cores,round(c(my_ram)/10^9,0)),"\n")
    dirpath <- dirpath1
    check_mac <- grepl("Apple",my_system$model_name)
    if(check_mac) free_cons <- c(availableCores())
    if(!check_mac) free_cons <- c(freeConnections()-1)
    cat("Number of free connections for doFuture/parallel =",c(free_cons),"\n")
  }
  codepath <- paste0(dirpath,dircode)
  respath <- paste0(dirpath,resdir)
  # Output file name
  outfile_name <- NULL
  if(!is.null(file_out)){
    outfile_name <- paste0(respath,file_out)
    # Check if results already exist
    #check_exists <-try(load(outfile_name),silent=TRUE,TRUE)
  }
  return(list(codepath=codepath,outfile_name=outfile_name))
}
```


```{r SourceCode, echo=TRUE, eval=TRUE}
## Get setup
get_setup <- setup_files(dirpath1=dirpath1,
dircode=c("GitHub/Forest-Search/R/"), 
resdir=c("GitHub/Forest-Search/paper/"),
dirpath2=c("/Users/larryleon/Documents/"),dir2_identifier="Apple",
file_out=file_out_here)

codepath <- get_setup$codepath
outfile_name <- get_setup$outfile_name

source(paste0(codepath,"source_forestsearch_v0.R"))
source_fs_functions(file_loc=codepath)

 if(!exists("forestsearch")){
 cat("Files not found when sourcing from:","\n")
 print(paste0(codepath,"source_forestsearch_v0.R"))
 stop("forestsearch code does not exist")  
 }
 
```


## Datasetup  
```{r Datasetup, echo=TRUE, eval=TRUE}
t.start.all<-proc.time()[3]
df.analysis<-gbsg
df.analysis<-within(df.analysis,{
id<-as.numeric(c(1:nrow(df.analysis)))  
# time to months
time_months<-rfstime/30.4375
grade3 <- ifelse(grade=="3",1,0)
treat <- hormon
})
confounders.name<-c("age","meno","size","grade3","nodes","pgr","er")
outcome.name<-c("time_months")
event.name<-c("status")
id.name<-c("id")
treat.name<-c("hormon")
# Calculate Cox and RMST
itt_tab<-SGtab(df=df.analysis,SG_flag="ITT",outcome.name=outcome.name,event.name=event.name,treat.name=treat.name,draws=0)

plot_twosample(df=df.analysis,tte.name=outcome.name,treat.name=treat.name,event.name=event.name,
col.treat="blue",col.control="darkgrey",choose_ylim=TRUE,               
ylab="Survival Probability", xlab="Months", show.Y.axis=TRUE,               
byrisk=6,show.med=FALSE,legend.cex=0.5,risk.cex=0.5,censor.cex=0.7,cox.cex=0.55,cex_Yaxis=0.65)

# For draws>0 (above) will calculate simultaneous band
#plotband_survdiff(res=itt_tab$rmst_fit)
print(itt_tab$res_out)

```

## Baseline summary table
```{r BaselineTable, echo=TRUE, eval=TRUE}

dfbl_exp <- df.analysis %>% select(treat,status,age,meno,size,grade,grade3,nodes,pgr,er)

as_kable_tbl <-
  tbl_summary(
  dfbl_exp,
  by = treat, # split table by group
  missing = "no" # don't list missing data separately
  ) %>%
  add_n() %>% # add column with total number of non-missing observations
  add_difference(pvalue_fun=function(x){round(x,3)})%>%
  add_stat_label

as_kable_tbl <- 
  as_kable_tbl %>% 
  as_kable_extra(
    booktabs = TRUE,
    longtable = FALSE,
    escape=TRUE,
    caption="\\label{tab:bl_exposure} Summary of events and baseline factors by treatment",
    linesep = "") %>%
    kableExtra::kable_styling(bootstrap_options=c("striped","hover"), full_width=F, position="center",font_size=10,latex_options=c("scale_down","hold_position")
  )

as_kable_tbl

```



## GRF analysis  
```{r GRF, echo=TRUE, eval=TRUE}

## GRF
grf_est1 <- grf.subg.harm.survival(data=df.analysis,
confounders.name = confounders.name, RCT=FALSE,
outcome.name=outcome.name, event.name=event.name, id.name=id.name, treat.name=treat.name,
maxdepth=2, n.min = 60, dmin.grf = 12, frac.tau=0.6, details=TRUE)

```

```{r GRFtrees, echo=TRUE, eval=TRUE}
# NOTE: In general for GRF trees
# leaf1 --> recommend control
# leaf2 --> recommend treatment
# Tree depth 1
plot(grf_est1$tree1,leaf.labels=c("Control","Treat"))
# Tree depth 2
plot(grf_est1$tree2,leaf.labels=c("Control","Treat"))
```

## Forest Search analysis  
```{r FS, echo=TRUE, eval=TRUE}

t.start.fs<-proc.time()[3]

use_lasso <- FALSE

hr.threshold<-1.25   # Initital candidates 
hr.consistency<-1.0  # Candidates for many splits
pconsistency.threshold <- 0.9
stop.threshold <- 0.9

fs.est <- forestsearch(df.analysis=df.analysis, Allconfounders.name=confounders.name,
outcome.name=outcome.name,treat.name=treat.name,
event.name=event.name,id.name=id.name,
hr.threshold=hr.threshold,hr.consistency=hr.consistency,stop.threshold=stop.threshold,
pconsistency.threshold=pconsistency.threshold, 
is.RCT=FALSE,
pstop_futile=0.50,
details=TRUE,
use_lasso=use_lasso, 
defaultcut_names=NULL,
cut_type="default",
dmin.grf=6, frac.tau=0.60, grf_depth=2,
maxk=2,
sg_focus="Nsg_only",
n.min=60,
fs.splits=1000,
d0.min=10,d1.min=10,
by.risk=12,
plot.sg=TRUE)

```


## Forest Search Bootstrap dofuture (doF)  
```{r FSbootstrap_doF, echo=TRUE, eval=TRUE}
library(doFuture)
library(doRNG)
registerDoFuture()
registerDoRNG()
# workers=48 works well on popOS
plan("multisession", workers=48)
t.start <- proc.time()[3]
# Bootstrap bias-correction 
fs_bc <- forestsearch_bootstrap_dofuture(fs.est=fs.est,nb_boots=NB,est.scale="hr",show_three=TRUE,details=TRUE)
t.now<-proc.time()[3]
tall.min<-(t.now-t.start.fs)/60
t.min<-(t.now-t.start)/60
cat("Minutes (total) for bootstrap",c(tall.min),"\n")
cat("Minutes (total) for analysis + (doFuture) bootstrap",c(tall.min),"\n")
# Reset workers to single
plan(sequential)

```

## Forest Search n-fold cross-validation  
```{r FSnfold, echo=TRUE, eval=TRUE}
library(doFuture)
library(doRNG)
registerDoFuture()
registerDoRNG()
# # workers=48 works well on popOS
plan("multisession", workers=48)
t.start<-proc.time()[3]

# Kfolds = n (default to n-fold cross-validations)

fs_OOB <- forestsearch_Kfold(fs.est=fs.est,est.scale="hr",details=FALSE)

# Reset workers to single
plan(sequential)

summary_OOB <- forestsearch_KfoldOut(res=fs_OOB,details=TRUE,outall=TRUE)

table(summary_OOB$SGs_found[,1])
table(summary_OOB$SGs_found[,2])

t.now<-proc.time()[3]
tall.min<-(t.now-t.start.fs)/60
t.min<-(t.now-t.start)/60
cat("Minutes (total) for analysis + (doFuture) bootstrap + N-fold",c(tall.min),"\n")
cat("Minutes for N-fold",c(t.min),"\n")
```

## Forest Search 10-fold cross-validation  
```{r FStenfold, echo=TRUE, eval=TRUE}
# If not already called
library(doFuture)
library(doRNG)
registerDoFuture()
registerDoRNG()

#nbrOfWorkers()
#nbrOfFreeWorkers()
#freeConnections()
# workers=48 works well on popOS
plan("multisession", workers=48)

fs_ten <- forestsearch_tenfold(fs.est=fs.est,sims=tenfoldsims,details=TRUE)

# Reset workers to single
plan(sequential)

print(fs_ten$find_summary)
print(fs_ten$sens_summary)

print(head(fs_ten$sens_out))
print(head(fs_ten$find_out))

t.now<-proc.time()[3]
tall.min<-(t.now-t.start.fs)/60
cat("Minutes (all analyses)",c(tall.min),"\n")

if(!is.null(outfile_name) & exists("fs_OOB")){
save(fs_bc, fs.est, tall.min, fs_OOB, summary_OOB, fs_ten, file=outfile_name)
cat("Saving file here:",c(outfile_name),"\n")
}
# Only saving 10-fold cross-validation
if(!is.null(outfile_name) & !exists("fs_OOB")){
save(fs_bc, fs.est, tall.min, fs_ten, file=outfile_name)
cat("Saving file here:",c(outfile_name),"\n")
}
```

