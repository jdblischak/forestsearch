---
title: "Improved MRCT Simulation Code"
subtitle: "Refactored Simsetup chunk using forestsearch/weightedsurv packages"
format:
  html:
    code-fold: true
    self-contained: true
---

# Improved Simulation Setup

This code chunk replaces the original `Simsetup` chunk from `mrct_legacy.qmd` with improved patterns from `mrct_recent.qmd`.

**Key improvements:**

1. Uses `forestsearch` and `weightedsurv` packages instead of sourcing R files
2. Uses `generate_aft_dgm_flex()` for flexible DGM creation with spline specifications
3. Uses `simulate_from_dgm()` for standardized data generation
4. Improved parallel processing with `doFuture` and progress reporting
5. Better error handling with `tryCatch` throughout
6. Modular helper functions for reusability
7. Modern data.table syntax with `:=` for in-place modification
8. Consistent variable naming with `z_` prefix convention
9. Comprehensive documentation with roxygen-style comments

```{r Simsetup_improved, message=FALSE}
#| label: simsetup-improved
#| code-fold: true

# =============================================================================
# Required packages
# =============================================================================
library(survival)
library(data.table)
library(grf)
library(doFuture)
library(doRNG)
library(progressr)
library(forestsearch)
library(weightedsurv)
library(gt)
library(ggplot2)
library(table1)

# Set theme for plots
theme_set(theme_minimal(base_size = 12))

# =============================================================================
# Null coalescing operator
# =============================================================================
`%||%` <- function(x, y) if (is.null(x)) y else x

# =============================================================================
# Helper: Setup parallel processing
# =============================================================================
setup_parallel <- function(plan_type = "multisession", workers = NULL, show_message = TRUE) {
  
  if (plan_type == "sequential") {
    plan(sequential)
    return(invisible())
  }
  
  if (is.null(workers)) {
    workers <- max(1, parallel::detectCores() - 1)
  }
  
  if (plan_type == "multisession") {
    plan(multisession, workers = workers)
  } else if (plan_type == "callr") {
    plan(future.callr::callr, workers = workers)
  } else if (plan_type == "multicore") {
    if (.Platform$OS.type == "unix") {
      plan(multicore, workers = workers)
    } else {
      plan(multisession, workers = workers)
    }
  }
  
  if (show_message) {
    message(sprintf("Parallel processing: %d workers using %s backend", 
                    workers, class(plan())[1]))
  }
}

# =============================================================================
# Helper: Report parallel backend information
# =============================================================================
report_parallel_backend <- function() {
  if (!is(plan(), "sequential")) {
    message(sprintf("Using %d cores with backend %s", 
                    nbrOfWorkers(), 
                    attr(plan("list")[[1]], "class")[2]))
  } else if (foreach::getDoParWorkers() > 1) {
    message(sprintf("Using %d cores with backend %s", 
                    foreach::getDoParWorkers(), 
                    foreach::getDoParName()))
  } else {
    message("Backend uses sequential processing.")
  }
}

# =============================================================================
# Main simulation function: mrct_APregion_sims
# =============================================================================
#' @param dgm Data generating mechanism from generate_aft_dgm_flex()
#' @param n_sims Number of simulations
#' @param n_sample Sample size per simulation (default: dgm super-population size)
#' @param wname Region indicator variable name (default: "z_AP")
#' @param bw Log HR for prognostic effect of region
#' @param sg_focus Subgroup selection: "minSG", "hr", or "maxSG"
#' @param maxk Maximum factors in combinations (1 or 2)
#' @param hr_threshold HR threshold for identification
#' @param hr_consistency Consistency threshold for HR
#' @param pconsistency_threshold Probability threshold for consistency
#' @param confounders_name Vector of confounder names
#' @param conf_force Vector of forced cuts
#' @param analysis_time Analysis time for admin censoring
#' @param cens_adjust Censoring rate adjustment
#' @param parallel_args Parallel processing arguments
#' @param details Print progress details
#' @param seed Base random seed
#' @return data.table with simulation results

mrct_APregion_sims <- function(
    dgm,
    n_sims,
    n_sample = NULL,
    wname = "z_AP",
    bw = -log(5),
    sg_focus = "minSG",
    maxk = 1,
    hr_threshold = 0.90,
    hr_consistency = 0.80,
    pconsistency_threshold = 0.90,
    confounders_name = NULL,
    conf_force = NULL,
    analysis_time = 60,
    cens_adjust = 0,
    parallel_args = list(plan = "multisession", workers = NULL, show_message = TRUE),
    details = FALSE,
    seed = NULL
) {
  
  t_start <- proc.time()[3]
  
  # Default sample size from dgm
  if (is.null(n_sample)) {
    n_sample <- nrow(dgm$df_super)
  }
  
  # Default confounders from dgm
  if (is.null(confounders_name)) {
    all_vars <- names(dgm$df_super)
    exclude_vars <- c("id", "treat", "tte", "event", "y_sim", "treat_sim", 
                      "event_sim", "t_true", "c_time", "lin_pred_0", "lin_pred_1",
                      "loghr_po", "entrytime", "flag_harm")
    confounders_name <- setdiff(all_vars[grepl("^z_|^ecog|^strat", all_vars)], exclude_vars)
  }
  
  # Default forced cuts
  if (is.null(conf_force)) {
    conf_force <- c("z_age <= 65", "z_bm <= 0", "z_bm <= 1", "z_bm <= 2", "z_bm <= 5")
  }
  
  # Setup parallel processing
  setup_parallel(
    plan_type = parallel_args$plan %||% "multisession",
    workers = parallel_args$workers,
    show_message = parallel_args$show_message %||% TRUE
  )
  
  report_parallel_backend()
  
  # Progress handlers
  handlers(global = TRUE)
  handlers("progress")
  
  # Run simulations
  results <- with_progress({
    p <- progressor(along = seq_len(n_sims))
    
    foreach(
      sim = seq_len(n_sims),
      .options.future = list(seed = TRUE),
      .combine = "rbind",
      .errorhandling = "pass",
      .packages = c("survival", "data.table", "forestsearch", "weightedsurv")
    ) %dofuture% {
      
      p(sprintf("Sim %d/%d", sim, n_sims))
      
      # Simulate data
      dfs <- simulate_from_dgm(
        dgm = dgm,
        n = n_sample,
        rand_ratio = 1,
        draw_treatment = TRUE,
        entry_var = if ("entrytime" %in% names(dgm$df_super)) "entrytime" else NULL,
        analysis_time = analysis_time,
        cens_adjust = cens_adjust,
        seed = if (!is.null(seed)) seed + sim else NULL
      )
      
      dfs <- as.data.table(dfs)
      
      # Split by region
      df_nonAP <- dfs[get(wname) == 0]
      df_AP <- dfs[get(wname) == 1]
      
      # Initialize
      n_test <- nrow(df_AP)
      n_train <- nrow(df_nonAP)
      n_itt <- nrow(dfs)
      
      # Safe Cox fitting
      safe_coxph <- function(formula, data) {
        fit <- tryCatch(
          summary(coxph(formula, data = data))$conf.int,
          error = function(e) NULL
        )
        if (!is.null(fit) && is.numeric(fit[1])) return(fit[1])
        return(NA_real_)
      }
      
      # HR estimates
      hr_train <- safe_coxph(Surv(y_sim, event_sim) ~ treat_sim, df_nonAP)
      
      if ("strat" %in% names(dfs)) {
        hr_itt <- safe_coxph(Surv(y_sim, event_sim) ~ treat_sim + strata(strat), dfs)
      } else {
        hr_itt <- safe_coxph(Surv(y_sim, event_sim) ~ treat_sim, dfs)
      }
      
      hr_ittX <- safe_coxph(
        as.formula(paste0("Surv(y_sim, event_sim) ~ treat_sim + strata(", wname, ")")), 
        dfs
      )
      
      # Initialize subgroup results
      hr_test <- NA_real_
      any_found <- 0
      sg_found <- "none"
      n_sg <- n_test
      hr_sg <- NA_real_
      prev_sg <- 1.0
      POhr_sg <- NA_real_
      
      # AP HR
      hr_test <- safe_coxph(Surv(y_sim, event_sim) ~ treat_sim, df_AP)
      
      if (!is.na(hr_test)) {
        
        if ("loghr_po" %in% names(df_AP)) {
          POhr_sg <- exp(mean(df_AP$loghr_po, na.rm = TRUE))
        }
        
        # Forest search
        fs_result <- tryCatch({
          forestsearch(
            df.analysis = as.data.frame(df_nonAP),
            df.test = as.data.frame(df_AP),
            confounders.name = confounders_name,
            outcome.name = "y_sim",
            treat.name = "treat_sim",
            event.name = "event_sim",
            id.name = if ("id" %in% names(df_nonAP)) "id" else NULL,
            potentialOutcome.name = if ("loghr_po" %in% names(df_nonAP)) "loghr_po" else NULL,
            hr.threshold = hr_threshold,
            hr.consistency = hr_consistency,
            pconsistency.threshold = pconsistency_threshold,
            sg_focus = sg_focus,
            conf_force = conf_force,
            maxk = maxk,
            n.min = 60,
            d0.min = 10,
            d1.min = 10,
            showten_subgroups = FALSE,
            details = FALSE,
            plot.sg = FALSE,
            parallel_args = list(plan = "sequential")
          )
        }, error = function(e) NULL)
        
        if (!is.null(fs_result)) {
          if (is.null(fs_result$sg.harm)) {
            any_found <- 0
            sg_found <- "none"
            n_sg <- n_test
            hr_sg <- hr_test
            prev_sg <- 1.0
          } else {
            any_found <- 1
            sg_found <- paste(fs_result$sg.harm, collapse = " & ")
            
            df_test <- fs_result$df.test
            if (!is.null(df_test) && "treat.recommend" %in% names(df_test)) {
              df_sg <- df_test[df_test$treat.recommend == 1, ]
              n_sg <- nrow(df_sg)
              prev_sg <- n_sg / n_test
              hr_sg <- safe_coxph(Surv(y_sim, event_sim) ~ treat_sim, df_sg)
              
              if ("loghr_po" %in% names(df_sg)) {
                POhr_sg <- exp(mean(df_sg$loghr_po, na.rm = TRUE))
              }
            }
          }
        }
      }
      
      data.table(
        sim = sim,
        n_itt = n_itt,
        hr_itt = hr_itt,
        hr_ittX = hr_ittX,
        n_train = n_train,
        hr_train = hr_train,
        n_test = n_test,
        hr_test = hr_test,
        any_found = any_found,
        sg_found = sg_found,
        n_sg = n_sg,
        hr_sg = hr_sg,
        POhr_sg = POhr_sg,
        prev_sg = prev_sg
      )
    }
  })
  
  plan(sequential)
  
  results <- as.data.table(results)
  results[, hr_sg_null := fifelse(any_found == 0, NA_real_, hr_sg)]
  
  # Report summary
  t_now <- proc.time()[3]
  t_min <- (t_now - t_start) / 60
  
  if (details) {
    message(sprintf("\n=== Simulation Complete ==="))
    message(sprintf("Total simulations: %d", n_sims))
    message(sprintf("Time elapsed: %.2f minutes", t_min))
    message(sprintf("Subgroups found: %.1f%%", 100 * mean(results$any_found, na.rm = TRUE)))
  }
  
  return(results)
}

# =============================================================================
# Summary output function: summaryout_mrct
# =============================================================================
summaryout_mrct <- function(
    pop_summary = NULL,
    mrct_sims,
    out_sgs = c("sg_found", "sg_biomarker", "sg_age"),
    out_sgs2 = c("sg_biomarker", "sg_age", "sg_male", "sg_ecog", "sg_histology", 
                 "sg_CTregimen", "sg_region", "sg_surgery", "sg_prior_treat"),
    out_est = "+ APflag + sg_le85 + APflag2 + APflag3 + hr_sg_null",
    sg_type = 1,
    tab_caption = "Identified subgroups and estimation summaries",
    showtable = TRUE
) {
  
  mrct_sims <- as.data.table(copy(mrct_sims))
  
  res <- list()
  
  if (!is.null(pop_summary)) {
    res$ahr_true <- round(pop_summary$AHR %||% NA, 4)
    res$ahr_unadj <- round(pop_summary$ITT_unadj %||% NA, 4)
    res$ahr_sR <- round(pop_summary$ITT_sR %||% NA, 4)
    res$ahr_sRw <- round(pop_summary$ITT_sRw %||% NA, 4)
    res$ahr_w1 <- round(pop_summary$W_1 %||% NA, 4)
    
    if (!is.na(res$ahr_true) && res$ahr_true != 0) {
      res$bias_unadj <- round(100 * (res$ahr_unadj - res$ahr_true) / res$ahr_true, 1)
      res$bias_sR <- round(100 * (res$ahr_sR - res$ahr_true) / res$ahr_true, 1)
      res$bias_sRw <- round(100 * (res$ahr_sRw - res$ahr_true) / res$ahr_true, 1)
      res$bias_w1 <- round(100 * (res$ahr_w1 - res$ahr_true) / res$ahr_true, 1)
    }
  }
  
  # Derived variables
  mrct_sims[, `:=`(
    APflag = fifelse(hr_test > 0.9, "AP > 0.9", "AP <= 0.9"),
    sg_le85 = fifelse(hr_sg <= 0.85, "AP(sg) <= 0.85", "AP(sg) > 0.85"),
    APflag2 = fifelse(hr_test > 0.9 & hr_sg <= 0.85, "AP > 0.9 & AP(sg) <= 0.85", "Not"),
    APflag3 = fifelse(hr_test > 0.9 & hr_sg <= 0.80, "AP > 0.9 & AP(sg) <= 0.80", "Not"),
    found = as.factor(any_found)
  )]
  
  # Classify subgroups
  mrct_sims[, `:=`(
    sg_biomarker = fifelse(grepl("bm|biomarker", sg_found, ignore.case = TRUE),
                           "biomarker", fifelse(sg_found != "none", "other", "none")),
    sg_age = fifelse(grepl("age", sg_found, ignore.case = TRUE),
                     "age", fifelse(sg_found != "none", "other", "none")),
    sg_male = fifelse(grepl("male|sex", sg_found, ignore.case = TRUE),
                      "sex", fifelse(sg_found != "none", "other", "none")),
    sg_ecog = fifelse(grepl("ecog", sg_found, ignore.case = TRUE),
                      "ecog", fifelse(sg_found != "none", "other", "none")),
    sg_histology = fifelse(grepl("histology", sg_found, ignore.case = TRUE),
                           "histology", fifelse(sg_found != "none", "other", "none")),
    sg_CTregimen = fifelse(grepl("CTregimen|chemo", sg_found, ignore.case = TRUE),
                           "CT_regimen", fifelse(sg_found != "none", "other", "none")),
    sg_region = fifelse(grepl("region|EU", sg_found, ignore.case = TRUE),
                        "region", fifelse(sg_found != "none", "other", "none")),
    sg_surgery = fifelse(grepl("surgery", sg_found, ignore.case = TRUE),
                         "surgery", fifelse(sg_found != "none", "other", "none")),
    sg_prior_treat = fifelse(grepl("prior_treat", sg_found, ignore.case = TRUE),
                             "prior_treat", fifelse(sg_found != "none", "other", "none"))
  )]
  
  outwhat1 <- "~ hr_itt + hr_ittX + hr_test + found + prev_sg + hr_sg + POhr_sg +"
  outwhat2 <- if (sg_type == 1) paste(out_sgs, collapse = " + ") else paste(out_sgs2, collapse = " + ")
  out_what <- as.formula(paste(outwhat1, outwhat2, out_est))
  
  out_table <- table1(out_what, data = mrct_sims, caption = tab_caption)
  
  if (showtable) print(out_table)
  
  return(list(res = res, out_table = out_table, data = mrct_sims))
}

# =============================================================================
# Plotting function: SGplot_estimates
# =============================================================================
SGplot_estimates <- function(
    df,
    label_training = "Training",
    label_testing = "Testing",
    label_itt = "ITT (stratified)",
    label_sg = "Testing (subgroup)"
) {
  
  df_itt <- data.table(est = df$hr_itt, analysis = label_itt)
  df_training <- data.table(est = df$hr_train, analysis = label_training)
  df_testing <- data.table(est = df$hr_test, analysis = label_testing)
  df_sg <- data.table(est = df$hr_sg, analysis = label_sg)
  
  hr_estimates <- rbind(df_itt, df_training, df_testing, df_sg)
  est_order <- c(label_itt, label_training, label_testing, label_sg)
  hr_estimates[, analysis := factor(analysis, levels = est_order)]
  
  p <- ggplot(hr_estimates, aes(x = analysis, y = est, fill = analysis)) +
    geom_violin(trim = FALSE, alpha = 0.7) +
    geom_boxplot(width = 0.15, fill = "white", alpha = 0.8) +
    geom_hline(yintercept = 1.0, linetype = "dashed", color = "red", alpha = 0.7) +
    scale_fill_brewer(palette = "Set2") +
    labs(
      x = "Analysis Population",
      y = "Hazard Ratio Estimate",
      title = "Distribution of HR Estimates Across Simulations"
    ) +
    theme_minimal(base_size = 12) +
    theme(
      legend.position = "none",
      axis.text.x = element_text(angle = 15, hjust = 1)
    )
  
  return(list(dfPlot_estimates = hr_estimates, plot_estimates = p))
}

# =============================================================================
# DGM creation wrapper
# =============================================================================
create_dgm_for_simulations <- function(
    df_case,
    model_type = c("alt", "null"),
    log_hrs = NULL,
    ap_effect = -log(5),
    verbose = FALSE
) {
  
  model_type <- match.arg(model_type)
  
  if (is.null(log_hrs)) {
    log_hrs <- if (model_type == "alt") log(c(2, 1.25, 0.5)) else log(c(0.7, 0.7, 0.7))
  }
  
  generate_aft_dgm_flex(
    data = df_case,
    continuous_vars = c("age", "bm"),
    factor_vars = c("male", "histology", "prior_treat", "AP"),
    set_beta_spec = list(set_var = c("z_AP"), beta_var = ap_effect),
    continuous_vars_cens = c("age"),
    factor_vars_cens = c("prior_treat"),
    cens_type = "weibull",
    outcome_var = "tte",
    event_var = "event",
    treatment_var = "treat",
    subgroup_vars = NULL,
    subgroup_cuts = NULL,
    model = model_type,
    spline_spec = list(var = "z_bm", knot = 5, zeta = 10, log_hrs = log_hrs),
    k_inter = 0.0,
    verbose = verbose,
    standardize = FALSE
  )
}
```

## Example: Simulations under Strong Biomarker Effect

```{r sims_alt_improved, echo=TRUE, message=FALSE, warning=TRUE, eval=FALSE}
#| label: sims-alt-improved

t_start <- proc.time()[3]

# Create DGM with strong biomarker effect
dgm_alt <- create_dgm_for_simulations(
  df_case = df.case,
  model_type = "alt",
  log_hrs = log(c(3, 1.25, 0.50)),
  verbose = TRUE
)

# Define analysis parameters
confounders_name <- c("z_age", "z_bm", "z_male", "ecog", "z_histology", "z_prior_treat", "strat")
conf_force <- c("z_age <= 65", "z_bm <= 0", "z_bm <= 1", "z_bm <= 2", "z_bm <= 5")

# Run simulations
n_sims <- 1000

mrct_sims_alt <- mrct_APregion_sims(
  dgm = dgm_alt,
  n_sims = n_sims,
  wname = "z_AP",
  bw = -log(5),
  sg_focus = "minSG",
  maxk = 1,
  hr_threshold = 0.90,
  hr_consistency = 0.80,
  pconsistency_threshold = 0.90,
  confounders_name = confounders_name,
  conf_force = conf_force,
  parallel_args = list(plan = "multisession", workers = NULL, show_message = TRUE),
  details = TRUE
)

t_elapsed <- (proc.time()[3] - t_start) / 60
cat("Minutes for simulations:", round(t_elapsed, 2), "\n")
cat("True positive rate:", round(100 * mean(mrct_sims_alt$any_found), 2), "%\n")

# Save results
if (output) save(n_sims, dgm_alt, mrct_sims_alt, file = "output/mrct_sims_alt_improved.Rdata")

# Summary output
temp <- summaryout_mrct(
  pop_summary = NULL,
  mrct_sims = mrct_sims_alt,
  sg_type = 1,
  tab_caption = "Subgroups under strong biomarker effects"
)

# Visualization
plot_alt <- SGplot_estimates(
  mrct_sims_alt,
  label_training = "Non-AP, ITT",
  label_itt = "Overall, ITT",
  label_testing = "AP, ITT",
  label_sg = "AP, identified subgroup"
)
print(plot_alt$plot_estimates)
```

## Example: Simulations under Null (Uniform Effect)

```{r sims_null_improved, echo=TRUE, message=FALSE, warning=TRUE, eval=FALSE}
#| label: sims-null-improved

t_start <- proc.time()[3]

# Create DGM with uniform effect (null hypothesis)
dgm_null <- create_dgm_for_simulations(
  df_case = df.case,
  model_type = "null",
  log_hrs = log(c(0.7, 0.7, 0.7)),
  verbose = TRUE
)

# Run simulations
n_sims <- 1000

mrct_sims_null <- mrct_APregion_sims(
  dgm = dgm_null,
  n_sims = n_sims,
  wname = "z_AP",
  bw = -log(5),
  sg_focus = "minSG",
  maxk = 1,
  hr_threshold = 0.90,
  hr_consistency = 0.80,
  pconsistency_threshold = 0.90,
  confounders_name = confounders_name,
  conf_force = conf_force,
  parallel_args = list(plan = "multisession", workers = NULL, show_message = TRUE),
  details = TRUE
)

t_elapsed <- (proc.time()[3] - t_start) / 60
cat("Minutes for simulations:", round(t_elapsed, 2), "\n")
cat("False positive rate:", round(100 * mean(mrct_sims_null$any_found), 2), "%\n")

# Save results
if (output) save(n_sims, dgm_null, mrct_sims_null, file = "output/mrct_sims_null_improved.Rdata")

# Summary output
temp <- summaryout_mrct(
  pop_summary = NULL,
  mrct_sims = mrct_sims_null,
  sg_type = 2,
  tab_caption = "Subgroups under uniform treatment effects (null)"
)

# Visualization
plot_null <- SGplot_estimates(
  mrct_sims_null,
  label_training = "Non-AP, ITT",
  label_itt = "Overall, ITT",
  label_testing = "AP, ITT",
  label_sg = "AP, identified subgroup"
)
print(plot_null$plot_estimates)
```

# Summary of Improvements

| Aspect | Legacy Code | Improved Code |
|--------|-------------|---------------|
| Package management | Sources R files | Uses installed packages |
| DGM creation | `get_dgm_stratified()` | `generate_aft_dgm_flex()` |
| Data simulation | `draw_sim_stratified()` | `simulate_from_dgm()` |
| Variable naming | Mixed conventions | Consistent `z_` prefix |
| Parallel processing | Basic doFuture | Enhanced with progress |
| Error handling | Basic try() | Comprehensive tryCatch |
| Documentation | Minimal | Roxygen-style comments |
| Modularity | Monolithic function | Helper functions |
