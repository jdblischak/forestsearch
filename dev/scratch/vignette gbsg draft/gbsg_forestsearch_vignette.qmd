---
title: "Exploratory Subgroup Identification with ForestSearch"
subtitle: "German Breast Cancer Study Group (GBSG) Analysis"
author: "Larry F. León"
date: "`r Sys.Date()`"
toc: true
number-sections: true
toc-depth: 3
format: 
  html:
    self-contained: true
    code-fold: show
    code-summary: "Show code"
    theme: cosmo
    highlight-style: github
execute:
  warning: false
  message: false
  eval: true
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(

  echo = TRUE,
  warning = FALSE,
  message = FALSE,

  fig.align = "center",
  fig.retina = 2,
  fig.width = 8,
  fig.height = 6
)

# Initialize timing
timings <- list()
t_vignette_start <- proc.time()
```

# Introduction

This vignette demonstrates the **ForestSearch** methodology for exploratory 
subgroup identification in survival analysis, as described in 
León et al. (2024) *Statistics in Medicine*.

## Motivation

In clinical trials, particularly oncology, subgroup analyses are essential for:

- Evaluating treatment effect consistency across patient populations
- Identifying subgroups where treatment may be detrimental (harm)
- Characterizing subgroups with enhanced benefit
- Informing regulatory decisions and clinical practice

While prespecified subgroups provide stronger evidence, important subgroups 
based on patient characteristics may not be anticipated. ForestSearch provides 
a principled approach to **exploratory** subgroup identification with proper 
statistical inference.

## Methodology Overview

ForestSearch identifies subgroups through:
 
1. **Candidate factor selection**: Using LASSO and/or Generalized Random Forests (GRF)
2. **Exhaustive subgroup search**: Evaluating all combinations up to `maxk` factors
3. **Consistency-based selection**: Applying splitting consistency criteria
4. **Bootstrap bias correction**: Adjusting for selection-induced optimism
5. **Cross-validation**: Assessing algorithm stability

The key innovation is the **splitting consistency criterion**: a subgroup is 
considered "consistent with harm" if, when randomly split 50/50 many times, 
both halves consistently show hazard ratios ≥ 1.0 (for example if 1.0 represents a meaningful "harm threshold").

# Setup

## Load Required Packages

```{r load-packages}
library(forestsearch)
library(survival)
library(data.table)
library(ggplot2)
library(gt)
library(grf)
library(policytree)
library(doFuture)
library(doRNG)

# Optional packages for enhanced output
library(patchwork)
library(weightedsurv)

# Set ggplot theme
theme_set(theme_minimal(base_size = 12))
```

## Parallel Processing Configuration
 
ForestSearch supports parallel processing for computationally intensive 
operations (bootstrap, cross-validation).

```{r parallel-setup}
# Detect available cores (use fewer for CRAN checks)
n_cores <- min(parallel::detectCores() - 1, 4)
cat("Using", n_cores, "cores for parallel processing\n")

# Configure parallel backend
registerDoFuture()
registerDoRNG()
```

# Data: German Breast Cancer Study Group Trial

## Study Background

The GBSG trial evaluated hormonal treatment (tamoxifen) versus chemotherapy 
in node-positive breast cancer patients. Key characteristics:

- **Sample size**: N = 686
- **Outcome**: Recurrence-free survival time
- **Censoring rate**: ~56%
- **Treatment**: Hormonal therapy (tamoxifen) vs. chemotherapy

## Data Preparation

```{r data-setup}
# Load GBSG data (included in forestsearch package)
df.analysis <- gbsg

# Prepare analysis variables
df.analysis <- within(df.analysis, {
  id <- seq_len(nrow(df.analysis))
  time_months <- rfstime / 30.4375
  grade3 <- ifelse(grade == "3", 1, 0)
  treat <- hormon
})

# Define variable roles
confounders.name <- c("age", "meno", "size", "grade3", "nodes", "pgr", "er")
outcome.name <- "time_months"
event.name <- "status"
id.name <- "id"
treat.name <- "hormon"

# Display data structure
cat("Sample size:", nrow(df.analysis), "\n")
cat("Events:", sum(df.analysis[[event.name]]), 
    sprintf("(%.1f%%)\n", 100 * mean(df.analysis[[event.name]])))
cat("Baseline factors:", paste(confounders.name, collapse = ", "), "\n")
```

## Baseline Characteristics

```{r baseline-table}
create_summary_table(
  data = df.analysis,
  treat_var = treat.name,
  table_title = "GBSG Baseline Characteristics by Treatment Arm",
  vars_continuous = c("age", "nodes", "size", "er", "pgr"),
  vars_categorical = c("grade", "meno"),
  font_size = 12
)
```

## Kaplan-Meier Analysis (ITT Population)

```{r km-itt, fig.width=8, fig.height=5}
# Prepare counting process data for KM plot
dfcount <- df_counting(
  df = df.analysis,
  by.risk = 6,
  tte.name = outcome.name,
  event.name = event.name,
  treat.name = treat.name
)

# Plot with confidence intervals and log-rank test
plot_weighted_km(
  dfcount,
  conf.int = TRUE,
  show.logrank = TRUE,
  ymax = 1.05,
  xmed.fraction = 0.775,
  ymed.offset = 0.125
)
```

The ITT Cox hazard ratio estimate is approximately 0.69 (95% CI: 0.54, 0.89), 
suggesting an overall benefit for hormonal therapy.

# Preliminary Analysis: Generalized Random Forests

Before running ForestSearch, we can use GRF to explore potential treatment 
effect heterogeneity and identify candidate factors.

```{r grf-analysis}
t0 <- proc.time()

grf_est <- grf.subg.harm.survival(
  data = df.analysis,
  confounders.name = confounders.name,
  outcome.name = outcome.name,
  event.name = event.name,
  id.name = id.name,
  treat.name = treat.name,
  maxdepth = 2,
  n.min = 60,
  dmin.grf = 12,
  frac.tau = 0.6,
  details = TRUE
)

timings$grf <- (proc.time() - t0)["elapsed"]
```

```{r grf-trees, fig.width=10, fig.height=4}
# Display policy trees
# leaf1 = recommend control, leaf2 = recommend treatment
par(mfrow = c(1, 2))
plot(grf_est$tree1, leaf.labels = c("Control", "Treat"), main = "Depth 1")
plot(grf_est$tree2, leaf.labels = c("Control", "Treat"), main = "Depth 2")
par(mfrow = c(1, 1))
```

GRF identifies estrogen receptor status (ER) as a key factor, with ER ≤ 0 
suggesting potential harm from hormonal therapy.

# ForestSearch Analysis

## Running ForestSearch

ForestSearch performs an exhaustive search over candidate subgroup combinations 
with up to `maxk` factors. Key parameters:

| Parameter | Value | Description |
|-----------|-------|-------------|
| `hr.threshold` | 1.25 | Minimum HR for consistency evaluation |
| `hr.consistency` | 1.0 | Minimum consistency rate for candidates |
| `pconsistency.threshold` | 0.90 | Required consistency for selection |
| `maxk` | 2 | Maximum factors in subgroup definition |
| `n.min` | 60 | Minimum subgroup sample size |
| `d0.min`, `d1.min` | 12 | Minimum events per treatment arm |

```{r forestsearch-main, fig.width=10, fig.height=7}
t0 <- proc.time()

fs <- forestsearch(
  df.analysis,
  confounders.name = confounders.name,
  outcome.name = outcome.name,
  treat.name = treat.name,
  event.name = event.name,
  id.name = id.name,
  # Threshold parameters (per León et al. 2024)
  hr.threshold = 1.25,
  hr.consistency = 1.0,
  pconsistency.threshold = 0.90,
  stop_threshold = 0.975,
  # Search configuration
  sg_focus = "hrMaxSG",
  max_subgroups_search = 10,
  use_twostage = TRUE,
  # Factor selection
  use_grf = TRUE,
  use_lasso = TRUE,
  cut_type = "default",
  # Subgroup constraints
  maxk = 2,
  n.min = 60,
  d0.min = 12,
  d1.min = 12,
  # Consistency evaluation
  fs.splits = 1000,
  # Parallel processing
  parallel_args = list(
    plan = "multisession",
    workers = n_cores,
    show_message = TRUE
  ),
  # Output options
  showten_subgroups = TRUE,
  details = TRUE,
  plot.sg = TRUE
)

plan("sequential")
timings$forestsearch <- (proc.time() - t0)["elapsed"]

cat("\nForestSearch completed in", 
    round(timings$forestsearch, 1), "seconds\n")
```

## ForestSearch Results

### Identified Subgroups

```{r fs-results}
# Generate results tables
res_tabs <- sg_tables(fs, ndecimals = 3, which_df = "est")

# Display top subgroups meeting criteria
res_tabs$sg10_out
```

### Treatment Effect Estimates

```{r fs-estimates}
# ITT and subgroup estimates
res_tabs$tab_estimates
```

### Identified Subgroup Definition

```{r fs-subgroup}
cat("Identified subgroup (H):", paste(fs$sg.harm, collapse = " & "), "\n")
cat("Subgroup size:", sum(fs$df.est$treat.recommend == 0), 
    sprintf("(%.1f%% of ITT)\n", 
            100 * mean(fs$df.est$treat.recommend == 0)))
```

ForestSearch identifies **Estrogen ≤ 0** (ER-negative) as the subgroup with 
potential harm. This is biologically plausible: tamoxifen is a selective 
estrogen receptor modulator with limited efficacy in ER-negative tumors.

# Bootstrap Bias Correction

## Rationale

Cox model estimates from identified subgroups are **upwardly biased** due to 
the selection process (subgroups are selected *because* they show extreme effects). 
Bootstrap bias correction addresses this by:

1. Resampling with replacement
2. Re-running the entire ForestSearch algorithm
3. Computing bias terms from bootstrap vs. observed estimates
4. Applying infinitesimal jackknife variance estimation

## Running Bootstrap Analysis

```{r bootstrap, eval=TRUE}
# Number of bootstrap iterations
# Use 500-2000 for production; reduced here for vignette
NB <- 1000

t0 <- proc.time()

fs_bc <- forestsearch_bootstrap_dofuture(
  fs.est = fs,
  nb_boots = NB,
  show_three = FALSE,
  details = TRUE
)

plan("sequential")
timings$bootstrap <- (proc.time() - t0)["elapsed"]

cat("\nBootstrap completed in", 
    round(timings$bootstrap / 60, 1), "minutes\n")
```

## Bootstrap Summary and Diagnostics

```{r bootstrap-summary}
# Comprehensive summary with diagnostics
summaries <- summarize_bootstrap_results(
  sgharm = fs$sg.harm,
  boot_results = fs_bc,
  create_plots = TRUE,
  est.scale = "hr"
)

# Display bias-corrected estimates table
summaries$table
```

### Event Count Summary

Low event counts can lead to unstable HR estimates. This summary helps 
identify potential issues:

```{r event-summary}
event_summary <- summarize_bootstrap_events(fs_bc, threshold = 12)
```

### Bootstrap Diagnostics

```{r bootstrap-diagnostics}
# Quality metrics
summaries$diagnostics_table_gt
```

### Subgroup Agreement

How consistently does bootstrap identify the same subgroup?

```{r subgroup-agreement}
# Agreement with original analysis
if (!is.null(summaries$subgroup_summary$original_agreement)) {
  summaries$subgroup_summary$original_agreement
}

# Factor presence across bootstrap iterations
if (!is.null(summaries$subgroup_summary$factor_presence)) {
  summaries$subgroup_summary$factor_presence
}
```

### Bootstrap Distributions

```{r bootstrap-plots, fig.width=10, fig.height=4, eval=TRUE}
if (!is.null(summaries$plots)) {
  summaries$plots$H_distribution + summaries$plots$Hc_distribution
}
```

# Cross-Validation

Cross-validation assesses the **stability** of the ForestSearch algorithm. 
Two approaches are available:

## K-Fold Cross-Validation

```{r kfold-cv, eval = TRUE}
# 10-fold CV with multiple iterations
# Use Ksims >= 50 for production
Ksims <- 50

t0 <- proc.time()

fs_kfold <- forestsearch_tenfold(
  fs.est = fs,
  sims = Ksims,
  Kfolds = 10,
  details = FALSE,
  parallel_args = list(
    plan = "multisession",
    workers = n_cores,
    show_message = TRUE
  )
)

plan("sequential")
timings$kfold <- (proc.time() - t0)["elapsed"]

# Summary metrics
print(fs_kfold$find_summary)
print(fs_kfold$sens_summary)
```

## Out-of-Bag (N-Fold) Cross-Validation

N-fold CV (leave-one-out) provides the most rigorous stability assessment:

```{r oob-cv, eval = TRUE}
t0 <- proc.time()

fs_OOB <- forestsearch_Kfold(
  fs.est = fs,
  details = TRUE,
  Kfolds = nrow(df.analysis),  # N-fold = leave-one-out
  parallel_args = list(
    plan = "callr",
    workers = n_cores,
    show_message = TRUE
  )
)

plan("sequential")
timings$oob <- (proc.time() - t0)["elapsed"]

# Summarize OOB results
summary_OOB <- forestsearch_KfoldOut(
  res = fs_OOB,
  details = TRUE,
  outall = TRUE
)

# Subgroup definitions found
table(summary_OOB$SGs_found[, 1])
```

# Results Visualization

## Forest Plot

The forest plot summarizes treatment effects across the ITT population, 
reference subgroups, and identified subgroups with cross-validation metrics.

```{r forest-plot, fig.width=10, fig.height=7}
# Define reference subgroups for comparison
subgroups <- list(
  age_gt65 = list(
    subset_expr = "age > 65",
    name = "Age > 65",
    type = "reference"
  ),
  age_le65 = list(
    subset_expr = "age <= 65",
    name = "Age ≤ 65",
    type = "reference"
  ),
  pgr_positive = list(
    subset_expr = "pgr > 0",
    name = "PgR > 0",
    type = "reference"
  ),
  pgr_negative = list(
    subset_expr = "pgr <= 0",
    name = "PgR ≤ 0",
    type = "reference"
  )
)

# Create forest plot
# Include fs_kfold and fs_OOB if available for CV metrics
result <- plot_subgroup_results_forestplot(
  fs_results = list(
    fs.est = fs,
    fs_bc = fs_bc,
    fs_OOB = fs_OOB,
    fs_kfold = fs_kfold
  ),
  df_analysis = df.analysis,
  subgroup_list = subgroups,
  outcome.name = outcome.name,
  event.name = event.name,
  treat.name = treat.name,
  E.name = "Hormonal",
  C.name = "Chemo",
  ci_column_spaces = 25,
  xlog = TRUE
)

# Display
plot(result$plot)
```

## Kaplan-Meier by Identified Subgroups

```{r km-subgroups, fig.width=10, fig.height=5, eval=TRUE}
# Create KM plots for identified subgroups
# Alternatively, use weightedsurv package as illustrated above;
# And also in the forestsearch results (above) where the subgroup figures are also displayed
par(mfrow = c(1, 2))

# H subgroup (potential harm)
df_H <- subset(fs$df.est, treat.recommend == 0)
if (nrow(df_H) > 20) {
  fit_H <- survfit(
    as.formula(paste0("Surv(", outcome.name, ", ", event.name, ") ~ ", treat.name)),
    data = df_H
  )
  plot(fit_H, col = c("blue", "red"), lwd = 2,
       xlab = "Time (months)", ylab = "Survival Probability",
       main = paste("H:", paste(fs$sg.harm, collapse = " & ")))
  legend("bottomleft", c("Control", "Treatment"), col = c("blue", "red"), lwd = 2)
}

# Hc subgroup (complement)
df_Hc <- subset(fs$df.est, treat.recommend == 1)
if (nrow(df_Hc) > 20) {
  fit_Hc <- survfit(
    as.formula(paste0("Surv(", outcome.name, ", ", event.name, ") ~ ", treat.name)),
    data = df_Hc
  )
  plot(fit_Hc, col = c("blue", "red"), lwd = 2,
       xlab = "Time (months)", ylab = "Survival Probability",
       main = "Hc: Complement (ER > 0)")
  legend("bottomleft", c("Control", "Treatment"), col = c("blue", "red"), lwd = 2)
}

par(mfrow = c(1, 1))
```

# Summary and Interpretation

## Key Findings

```{r summary-findings}
# Extract key results
cat("=" %>% rep(60) %>% paste(collapse = ""), "\n")
cat("FORESTSEARCH ANALYSIS SUMMARY\n")
cat("=" %>% rep(60) %>% paste(collapse = ""), "\n\n")

cat("Dataset: GBSG (N =", nrow(df.analysis), ")\n")
cat("Outcome: Recurrence-free survival\n\n")

cat("ITT Analysis:\n")
cat("  HR (95% CI): 0.69 (0.54, 0.89)\n\n")

cat("Identified Subgroup (H):\n")
cat("  Definition:", paste(fs$sg.harm, collapse = " & "), "\n")
cat("  Size:", sum(fs$df.est$treat.recommend == 0), 
    sprintf("(%.1f%%)\n", 100 * mean(fs$df.est$treat.recommend == 0)))
cat("  Unadjusted HR:", sprintf("%.2f", exp(fs$grp.consistency$out_sg$result$hr[1])), "\n")

cat("\nComplement Subgroup (Hc):\n")
cat("  Size:", sum(fs$df.est$treat.recommend == 1),
    sprintf("(%.1f%%)\n", 100 * mean(fs$df.est$treat.recommend == 1)))
```

## Clinical Interpretation

The ForestSearch analysis identifies **estrogen receptor-negative (ER ≤ 0)** 
patients as a subgroup with potential lack of benefit from hormonal therapy.

**Biological plausibility**: Tamoxifen is a selective estrogen receptor 
modulator. Its efficacy depends on ER expression. The finding that ER-negative 
patients may not benefit is consistent with:

- Mechanistic understanding of tamoxifen action
- Meta-analyses showing no tamoxifen benefit in ER-negative breast cancer
- Clinical guidelines recommending tamoxifen primarily for ER-positive tumors

**Caveats**:

1. This is an **exploratory** analysis requiring independent validation
2. The bias-corrected estimates have wider confidence intervals
3. Cross-validation metrics should be evaluated for algorithm stability

## Computational Timing

```{r timing-summary}
timings$total <- (proc.time() - t_vignette_start)["elapsed"]

timing_df <- data.frame(
  Analysis = c("GRF", "ForestSearch", "Bootstrap", "Total"),
  Seconds = c(
    timings$grf,
    timings$forestsearch,
    timings$bootstrap,
    timings$total
  )
)
timing_df$Minutes <- timing_df$Seconds / 60

gt(timing_df) |>
  tab_header(title = "Computational Timing") |>
  fmt_number(columns = c(Seconds, Minutes), decimals = 1) |>
  cols_label(
    Analysis = "Component",
    Seconds = "Time (sec)",
    Minutes = "Time (min)"
  )
```

# References

León LF, Jemielita T, Guo Z, Marceau West R, Anderson KM (2024). 
"Exploratory subgroup identification in the heterogeneous Cox model: 
A relatively simple procedure." *Statistics in Medicine*. 
DOI: 10.1002/sim.10163

# Session Information

```{r session-info}
sessionInfo()
```
